library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity CrossPainter is

	Port(
	
		--Pris de CrossAverager
		R : in STD_LOGIC_VECTOR(7 downto 0);
		
		X : in STD_LOGIC_VECTOR(12 downto 0);
		Y : in STD_LOGIC_VECTOR(12 downto 0);
		
		valide : in STD_LOGIC;
		
		--Pris du VGA_Controller
		H : in STD_LOGIC_VECTOR(12 downto 0);
		V : in STD_LOGIC_VECTOR(12 downto 0);
		
		clock, clk_1HZ : in STD_LOGIC;
		
		blank : in STD_LOGIC;
		
		--Sortie couleurs
		LCDR : out STD_LOGIC_VECTOR(7 downto 0);
		LCDG : out STD_LOGIC_VECTOR(7 downto 0) := (others => '0');
		LCDB : out STD_LOGIC_VECTOR(7 downto 0) := (others => '0');
		
		-- Sortie XCross et yCross (debug)
		xc : out unsigned(12 downto 0);
		yc : out unsigned(12 downto 0)
		
	);
end CrossPainter;



architecture CrossArchi of CrossPainter is

signal xCross : unsigned(12 downto 0);
signal yCross : unsigned(12 downto 0);
signal cpt : unsigned(3 downto 0) := to_unsigned(0,4); -- Affichage xCross yCross

begin

	-- PROCESS DU DESSIN
	process(clock)
	
	begin
	if clock'event and clock = '1' then	
--		if(clk_1HZ'event and clk_1HZ = '1') then
--			cpt <= cpt + 1;
--		end if;
		
		if valide = '1' then
			xCross <= unsigned(X);
			yCross <= unsigned(Y);
			cpt <= to_unsigned(0,4);
		
		else
			xCross <= xCross;
			yCross <= yCross;
		end if;
		
		if blank = '1' then
			--DÃ©termine si le pixel fait partie de la croix    V : Horizontal   H : Vertical
			if (  unsigned(H) = xCross  )    or    (  unsigned(V) = yCross  ) then
				LCDR <= ( others => '0');
				LCDG <= ( others => '0');
				LCDB <= std_logic_vector(to_unsigned(200, LCDB'length));
			else
				LCDR <= R;
				LCDG <= (others => '0');
				LCDB <= (others => '0');
			end if;
		end if;
	end if;	
	end process;
	
end CrossArchi;